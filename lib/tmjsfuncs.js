//
// Travel Mapping (TM) Data Viewer-related Javascript functions
// formerly for Clinched Highway Mapping (CHM) data
//
// Load and view data files related to TM-related academic data sets.
//
// Renamed as tmjsfuncs.js as part of the Travel Mapping project
//
// Primary author: Jim Teresco, Siena College, The College of Saint Rose
// Additional authors: Razie Fathi, Arjol Pengu, Maria Bamundo, Clarice Tarbay
//
// Portions of this code developed based on examples from 
// http://cmap.m-plex.com/tools/wptedit/wptedit.html
// http://www.alecjacobson.com/weblog/?p=1645
//
// Modification History (pre-GitHub):
//
// 2011-06-20 JDT  Initial implementation
// 2011-06-21 JDT  Added .gra support and checkbox for hidden marker display
// 2011-06-23 JDT  Added .nmp file support (near-miss points)
// 2011-08-23 JDT  Added .pth file support (path)
// 2011-08-31 JDT  Added tabular graph data display
// 2013-08-14 JDT  Completed conversion to Google Maps API V3
// 2013-08-15 JDT  Added custom icon for intersections
// 2013-12-08 JDT  Fixed to handle DOS-style CRLF in uploaded files
// 2013-12-25 JDT  Click on GRA, PTH point label in table recenters map
// 2014-11-17 JDT  Added .wpl file support (waypoint list)
// 2015-06-10 JDT  Adapted for reading from database entries using PHP
// 2015-06-14 JDT  Clinched segment support
// 2015-06-17 JDT  All highways in region support
// 2015-08-19 JDT  Fixed a few bugs with infowindows
// 2016-05-25 JDT  Consolidated some changes from copies of chmviewerfunc3.js
// 2016-06-27 JDT  Removed code not needed by TM
//

// IMPORTANT: when making any modifications to code here, especially
// the loadmap function, note that it is used by various TM pages,
// where variables are mostly set in code generated by waypoints.js.php,
// but also by HDX, where variables are set in various places in
// hdxjsfuncs.js

// get path to lib directory where some images are found,
// which *might* have been set from an hdx.conf file.
var tmlibdir = "/lib/";
try {
    tmlibdir = tmliburl;
}
catch(e) {}

// global variable to hold the map, which will be assigned a
// Leaflet L.Map reference
var map;

// map status possibilities
var mapStates = {
    NO_MAP: 1,
    HB_ROUTE: 2,
    MAPVIEW: 3,
    HDX: 4
};

var mapStatus = mapStates.NO_MAP;

// many of the following are given values in code generated by
// waypoints.js.php for TM functionality, or by functions in
// hdx*.js (in EduTools/HighwayDataExaminer) for HDX functionality.

// array of waypoints displayed
var waypoints = new Array();
// array of waypoint custom marker colors (used for NMPs)
var waypointColors = new Array();
// info about each route included (each entry is a structure)
var routeInfo = new Array();
// the markers at those waypoints
var markers = new Array();
// the info displayed when markers are clicked
var markerinfo = new Array();
// array of LatLng representing the waypoint coordinates
var polypoints = new Array();
// array of connections on map as Polyline overlays
var connections = new Array();

// highlight connection when a popup on it is displayed
var highlightConnection = null;

// highlight hover route in mapview
var mapviewHoverRoute = null;

// array of graph edges (for graph data, used by HDX, which imports this code) -
// this would be a single list of all graph edges.  When using an adjacency
// list representation, edges would also be in vertex-based adjacency lists
var graphEdges = new Array();
// boolean to determine if graph edges should be generated automatically
var genEdges = false;
// boolean to determine if graph edges are in vertex adjacency lists
var usingAdjacencyLists = false;
// boolean to determine if graph edges include traveler info
var haveTravelers = false;
// array of traveler names corresponding to traveler numbers for edges
var travelerNames = new Array();
// largest number of travelers on any edge
var maxEdgeTravelers = 0;

// array of segments and clinched for "clinched by traveler" mapping
var segments = new Array();
var clinched = new Array();
// boolean to say if we're doing this
var mapClinched = false;
// traveler name for clinched
var traveler;

// preferred units
var distanceUnits = "miles";

// array of objects that define color codes from names in the DB
var colorCodes = new Array();
colorCodes[0] = { name: "blue", unclinched: "rgb(100,100,255)", clinched: "rgb(0,0,220)" };
colorCodes[1] = { name: "brown", unclinched: "rgb(153,152,102)", clinched: "rgb(153,102,0)" };
colorCodes[2] = { name: "red", unclinched: "rgb(255,100,100)", clinched: "rgb(224,0,0)" };
colorCodes[3] = { name: "yellow", unclinched: "rgb(255,216,100)", clinched: "rgb(232,176,0)" };
colorCodes[4] = { name: "teal", unclinched: "rgb(100,200,200)", clinched: "rgb(0,140,160)" };
colorCodes[5] = { name: "green", unclinched: "rgb(100,200,100)", clinched: "rgb(0,224,0)" };
colorCodes[6] = { name: "magenta", unclinched: "rgb(255,100,255)", clinched: "rgb(208,0,208)" };
colorCodes[7] = { name: "lightsalmon", unclinched: "rgb(224,162,162)", clinched: "rgb(240,150,115)" };

// array of custom color codes to be pulled from query string parameter
// "colors="
var customColorCodes = new Array();

// current Polyline weight, updated by zoomChange
var polylineWeight = 10;

var intersectionimage = L.icon({
    iconUrl: tmlibdir + 'Intersection.png',
    // This marker is 16x16
    iconSize: [16, 16]});

var oldintersectionimage = L.icon({
    iconUrl: tmlibdir + 'smallintersection.png',
    // This marker is 16x16
    iconSize: [16, 16]});

// map tiles associative array will be filled in by loadmap
var baseLayers;

// functions to manage browser cookies for remembering last selected
// map tile base layer (based on examples at
// https://www.w3schools.com/js/js_cookies.asp)
function set_maptile_cookie(layerName) {

    // we'll have the cookie remain for a year
    var d = new Date();
    d.setTime(d.getTime() + 365*24*60*60*1000);
    document.cookie = "maptile=" + layerName + ";expires="
	+ d.toUTCString() + ";path=/";
}

function get_maptile_cookie() {

    var allcookies = decodeURIComponent(document.cookie).split(';');
    for (var i = 0; i < allcookies.length; i++) {
	var cookie = allcookies[i];
	// remove leading spaces
	while (cookie.charAt(0) == ' ') {
	    cookie = cookie.substring(1);
	}
	if (cookie.indexOf("maptile") == 0) {
	    return cookie.substring("maptile=".length, cookie.length);
	}
    }
    return "";
}

function set_distance_units_from_cookie() {

    let allcookies = decodeURIComponent(document.cookie).split(';');
    for (let i = 0; i < allcookies.length; i++) {
	let cookie = allcookies[i];
	// remove leading spaces
	while (cookie.charAt(0) == ' ') {
	    cookie = cookie.substring(1);
	}
	if (cookie.indexOf("units") == 0) {
	    distanceUnits = cookie.substring("units=".length, cookie.length);
	    return;
	}
    }
}

function length_in_current_units(miles) {

    if (distanceUnits == "miles") {
	return miles.toFixed(2) + " mi";
    }
    if (distanceUnits == "km") {
	return (miles * 1.609344).toFixed(2) + " km";
    }
    if (distanceUnits == "ft") {
	return (miles * 5280).toFixed(1) + " ft";
    }
    if (distanceUnits == "meters") {
	return (miles * 1609.344).toFixed(1) + " m";
    }
}


// loadmap constructs and sets up the initial map
function loadmap() {

    // Leaflet map object
    map = L.map('map', {
	renderer: L.canvas()});

    // set with initial coordinates at Roger Bacon 321 at Siena
    // College
    map.setView([42.719450, -73.752063], 16);

    // set up map tiles based on
    // https://github.com/leaflet-extras/leaflet-providers/blob/master/index.html
    baseLayers = {
	'OpenStreetMap Default': L.tileLayer.provider('OpenStreetMap.Mapnik'),
	'OpenStreetMap German Style': L.tileLayer.provider('OpenStreetMap.DE'),
	'OpenStreetMap Black and White': L.tileLayer.provider('OpenStreetMap.BlackAndWhite'),
	'OpenStreetMap H.O.T.': L.tileLayer.provider('OpenStreetMap.HOT'),
	'Thunderforest OpenCycleMap': L.tileLayer.provider('Thunderforest.OpenCycleMap', {
	    apikey: tf_map_key
	}),
	'Thunderforest Transport': L.tileLayer.provider('Thunderforest.Transport', {
	    apikey: tf_map_key
	}),
	'Thunderforest TransportDark': L.tileLayer.provider('Thunderforest.TransportDark', {
	    apikey: tf_map_key
	}),
	'Thunderforest Landscape': L.tileLayer.provider('Thunderforest.Landscape', {
	    apikey: tf_map_key
	}),
	'Thunderforest Outdoors': L.tileLayer.provider('Thunderforest.Outdoors', {
	    apikey: tf_map_key
	}),
	'Thunderforest Pioneer': L.tileLayer.provider('Thunderforest.Pioneer', {
	    apikey: tf_map_key
	}),
	'Thunderforest Spinal Map': L.tileLayer.provider('Thunderforest.SpinalMap', {
	    apikey: tf_map_key
	}),
	'Mapbox Streets': L.tileLayer.provider('MapBox', {
	    id: 'mapbox.streets',
	    accessToken: mapbox_token
	}),
	'Mapbox Satellite': L.tileLayer.provider('MapBox', {
	    id: 'mapbox.satellite',
	    accessToken: mapbox_token
	}),
	'Mapbox Streets+Satellite': L.tileLayer.provider('MapBox', {
	    id: 'mapbox.streets-satellite',
	    accessToken: mapbox_token
	}),
	'Mapbox Emerald': L.tileLayer.provider('MapBox', {
	    id: 'mapbox.emerald',
	    accessToken: mapbox_token
	}),
	'Hydda Full': L.tileLayer.provider('Hydda.Full'),
	'Stamen Toner': L.tileLayer.provider('Stamen.Toner'),
	'Stamen Terrain': L.tileLayer.provider('Stamen.Terrain'),
	'Stamen Watercolor': L.tileLayer.provider('Stamen.Watercolor'),
	'Esri WorldStreetMap': L.tileLayer.provider('Esri.WorldStreetMap'),
	'Esri DeLorme': L.tileLayer.provider('Esri.DeLorme'),
	'Esri WorldTopoMap': L.tileLayer.provider('Esri.WorldTopoMap'),
	'Esri WorldImagery': L.tileLayer.provider('Esri.WorldImagery'),
	'Esri WorldTerrain': L.tileLayer.provider('Esri.WorldTerrain'),
	'Esri WorldShadedRelief': L.tileLayer.provider('Esri.WorldShadedRelief'),
	'Esri WorldPhysical': L.tileLayer.provider('Esri.WorldPhysical'),
	'Esri OceanBasemap': L.tileLayer.provider('Esri.OceanBasemap'),
	'Esri NatGeoWorldMap': L.tileLayer.provider('Esri.NatGeoWorldMap'),
	'Esri WorldGrayCanvas': L.tileLayer.provider('Esri.WorldGrayCanvas'),
	'HERE Normal Day': L.tileLayer.provider('HERE.terrainDay', {
	    app_id: here_map_id, 
	    app_code: here_map_code
	}),
	'HERE Hybrid Day': L.tileLayer.provider('HERE.hybridDay', {
	    app_id: here_map_id, 
	    app_code: here_map_code
	}),
	'TM Blank White': L.tileLayer.provider('TMBlank.White'),
	'TM Blank Black': L.tileLayer.provider('TMBlank.Black')
    };
    var overlays = { };
    L.control.layers(baseLayers, overlays).addTo(map);

    // set layer to start with based on cookie if one exists
    let defaultLayerName = 'OpenStreetMap Default';
    let cookieLayerName = get_maptile_cookie();
    if (cookieLayerName != "" && cookieLayerName in baseLayers) {
	defaultLayerName = cookieLayerName;
    }
    baseLayers[defaultLayerName].addTo(map);

    // if map tile layer is changed, remember it in a cookie
    map.on('baselayerchange', function(e) {
	let selectedMap = "NOT FOUND";
	for (var mapname in baseLayers) {
	    if (map.hasLayer(baseLayers[mapname])) {
		selectedMap = mapname;
		break;
	    }
	}
	set_maptile_cookie(selectedMap);
    });
}

// construct a new Waypoint object (based on similar function by Tim Reichard)
// now supporting edge adjacency lists
// these sometimes have a field "intersecting" added to them which is
// an array of intersecting Routes (defined below)
function Waypoint(label, lat, lon, elabel, edgeList) {
    this.label = label;
    this.lat = parseFloat(lat).toFixed(6);
    this.lon = parseFloat(lon).toFixed(6);
    this.visible = true;
    if (label.indexOf("+") >= 0) {
	this.visible = false;
    }
    this.elabel = elabel;
    this.edgeList = edgeList;
    return this;
}

// construct a Route object to encapsulate information needed for intersecting
// routes
function Route(root, route, region, banner, abbrev, city) {

    this.root = root;
    this.route = route;
    this.region = region;
    this.banner = banner;
    this.abbrev = abbrev;
    this.city = city;
    return this;
}

// update the map to the current set of waypoints and connections
function updateMap()
{
    // remove any existing Polyline connections shown
    for (var i = 0; i < connections.length; i++) {
	connections[i].remove();
    }
    connections = new Array();

    // set up to find bounding box of points we plot
    var minlat = 999;
    var maxlat = -999;
    var minlon = 999;
    var maxlon = -999;

    // remove any markers previously on the map
    for (var i = 0; i < markers.length; i++) {
	markers[i].remove();
    }
    markers = new Array();

    // set variable that determine if markers should be drawn on the map
    var showMarkers = true;
    if (document.getElementById('showMarkers') != null) {
      showMarkers = document.getElementById('showMarkers').checked;
    }

    // draw our waypoint markers
    markerinfo = new Array();
    polypoints = new Array();

    for (var i = 0; i < waypoints.length; i++) {
	minlat = Math.min(minlat, waypoints[i].lat);
	maxlat = Math.max(maxlat, waypoints[i].lat);
	minlon = Math.min(minlon, waypoints[i].lon);
	maxlon = Math.max(maxlon, waypoints[i].lon);
	
	polypoints[i] = [waypoints[i].lat, waypoints[i].lon];
	
	markerinfo[i] = markerInfo(i, waypoints[i]);
	let icon = intersectionimage;
	if (waypointColors.length > i) {
	    let options = {
		iconShape: 'circle-dot',
		iconSize: [4, 4],
		iconAnchor: [4, 4],
		borderWidth: 4,
		borderColor: waypointColors[i]
	    };
	    
	    icon = L.BeautifyIcon.icon(options);
	}
	markers[i] = L.marker(polypoints[i], {
	    title: waypoints[i].label,
	    icon: icon
	});
	if (showMarkers && waypoints[i].visible) {
	    addMarker(markers[i], markerinfo[i], i);
	}
    }

    // set our map view according to the bounds we found
    map.fitBounds([[minlat, minlon],[maxlat, maxlon]]);

    // determine if the user has selected a custom unit of distance
    set_distance_units_from_cookie();
    
    // if this is a graph in HDX, we draw edges as connections,
    // otherwise we may be connecting waypoints in order to plot a
    // path
    if (graphEdges.length > 0) {
	for (var i = 0; i < graphEdges.length; i++) {
	    var numPoints;
	    if (graphEdges[i].via == null) {
		numPoints = 2;
	    }
	    else {
		numPoints = graphEdges[i].via.length/2 + 2;
	    }
	    var edgePoints = new Array(numPoints);
	    var v1 = graphEdges[i].v1;
	    var v2 = graphEdges[i].v2;
	    //	    DBG.write("Adding edge " + i + " from " + v1 + "(" + waypoints[v1].lat + "," + waypoints[v1].lon + ") to " + v2 + "(" + waypoints[v2].lat + "," + waypoints[v2].lon + ")");
	    edgePoints[0] = [waypoints[v1].lat, waypoints[v1].lon];
	    nextPoint = 1;
	    if (graphEdges[i].via != null) {
		for (var j = 0; j < graphEdges[i].via.length; j+=2) {
		    edgePoints[nextPoint] = [graphEdges[i].via[j], graphEdges[i].via[j+1]];
		    nextPoint++;
		}
	    }
	    edgePoints[nextPoint] = [waypoints[v2].lat, waypoints[v2].lon];
	    // check for custom colors for NMP "graphs"
	    if (waypointColors.length > v2) {
		color = waypointColors[v2];
	    }
	    else {
		color = getGraphEdgeColor(graphEdges[i]);
	    }
            connections[i] = L.polyline(edgePoints, {
                color: color,
                weight: polylineWeight,
                opacity: 0.4
            }).addTo(map);
	    connectionListener({connIndex: i});
	}
    }
    else if (usingAdjacencyLists) {
	// From HDX, TMG files and PTH files use adjacency lists, but
	// TMG files also have a graph edges array, so are handled above
	// meaning that much of this code is overkill, as PTH file "graphs"
	// are fairly trivial
	var edgeNum = 0;
	for (var i = 0; i < waypoints.length; i++) {
	    for (var j = 0; j < waypoints[i].edgeList.length; j++) {
		var thisEdge = waypoints[i].edgeList[j];
		// avoid double plot by only plotting those with v1 as i
		if (thisEdge.v1 == i) {
		    var numPoints;
		    if (thisEdge.via == null) {
			numPoints = 2;
		    }
		    else {
			numPoints = thisEdge.via.length/2 + 2;
		    }
		    var edgePoints = new Array(numPoints);
		    edgePoints[0] = [waypoints[thisEdge.v1].lat, waypoints[thisEdge.v1].lon];
		    nextPoint = 1;
		    if (thisEdge.via != null) {
			for (var p = 0; p < thisEdge.via.length; p+=2) {
			    edgePoints[nextPoint] = [thisEdge.via[p], thisEdge.via[p+1]];
			    nextPoint++;
			}
		    }
		    edgePoints[nextPoint] = [waypoints[thisEdge.v2].lat, waypoints[thisEdge.v2].lon];
		    
		    color = getGraphEdgeColor(thisEdge);
                    connections[edgeNum] = L.polyline(edgePoints, {
                        color: color,
                        weight: polylineWeight,
                        opacity: 0.4
                    }).addTo(map);
		    connectionListener({connIndex: edgeNum});
		    edgeNum++;
		}
	    }
	}
        map.on('zoomend', zoomChange);
        zoomChange();
    }
    // connecting waypoints in order to plot a path
    // this could be a single route in an HB context or a bunch of
    // routes in a mapview context (also, system/region)
    else if (mapClinched) {
	// clinched vs unclinched segments mapped with different colors
	var nextClinchedCheck = 0;
	var totalMiles = 0.0;
	var clinchedMiles = 0.0;
	var level = map.getZoom();
	var weight = 2;
	if (routeInfo.length > 0) {
	    // if routeInfo is not empty, we're plotting multiple routes
	    // (maybe check mapStatus for MAPVIEW instead, needs testing)
	    var nextSegment = 0;
	    // segmentLengths will have properties added to it where
	    // keys are the lengths of segments and the value for each
	    // is a list of segment numbers which are of that length, used
	    // to make sure only one Polyline is plotted for any segment
	    // that contains concurrencies
	    let segmentLengths = new Object();
	    for (var route = 0; route < routeInfo.length; route++) {
		var start = routeInfo[route].firstWaypoint;
		var end;
		if (route == routeInfo.length-1) {
		    end = waypoints.length-1;
		}
		else {
		    end = routeInfo[route+1].firstWaypoint-1;
		}
		// support for clinch colors from systems.csv
		var unclinchedColor = "rgb(200,200,200)"; //"#cccccc";
		var clinchedColor = "rgb(255,128,128)"; //"#ff8080";
		for (var c = 0; c<colorCodes.length; c++) {
		    if (colorCodes[c].name == routeInfo[route].color) {
			unclinchedColor = colorCodes[c].unclinched;
			clinchedColor = colorCodes[c].clinched;
		    }
		}
		// override with tier or system colors given in query string if they match
		for (var c = 0; c<customColorCodes.length; c++) {
		    if (customColorCodes[c].name == ("tier"+routeInfo[route].tier)) {
			unclinchedColor = customColorCodes[c].unclinched;
			clinchedColor = customColorCodes[c].clinched;
		    }
		    if (customColorCodes[c].name == routeInfo[route].system) {
			unclinchedColor = customColorCodes[c].unclinched;
			clinchedColor = customColorCodes[c].clinched;
		    }
		}
		// remember the index into the connections array where this
		// route's first connection is stored, as an aid for
		// later concurrency detection
		routeInfo[route].firstConnection = nextSegment;
		for (var i=start; i<end; i++) {
		    var edgePoints = new Array(2);
		    edgePoints[0] = [waypoints[i].lat, waypoints[i].lon];
		    edgePoints[1] = [waypoints[i+1].lat, waypoints[i+1].lon];
		    var segmentLength = distanceInMiles(waypoints[i].lat,
							waypoints[i].lon,
							waypoints[i+1].lat,
							waypoints[i+1].lon);
		    totalMiles += segmentLength;
		    var color = unclinchedColor;
		    var opacity = 0.3;
		    if (segments[nextSegment] == clinched[nextClinchedCheck]) {
			color = clinchedColor;
			nextClinchedCheck++;
			clinchedMiles += segmentLength;
			opacity = 0.85;
		    }
                    connections[nextSegment] = L.polyline(edgePoints, {
                        color: color,
                        weight: polylineWeight,
                        opacity: opacity
                    }).addTo(map);
		    let routesHere = new Array();
		    routesHere.push(route);

		    // expand out across hidden waypoints for user-meaningful
		    // endpoints and length
		    // also build list of waypoint coords for highlightConnection
		    let hcPointList = new Array();
		    let segStart = i;
		    while (segStart > start && !waypoints[segStart].visible) {
			segStart--;
		    }
		    let segEnd = i+1;
		    while (segEnd < end && !waypoints[segEnd].visible) {
			segEnd++;
		    }
		    let length = distanceInMiles(waypoints[segStart].lat,
						 waypoints[segStart].lon,
						 waypoints[segStart+1].lat,
						 waypoints[segStart+1].lon);
		    hcPointList.push([waypoints[segStart].lat,
				      waypoints[segStart].lon]);
		    hcPointList.push([waypoints[segStart+1].lat,
				      waypoints[segStart+1].lon]);
		    for (let point = segStart + 1; point < segEnd; point++) {
			length += distanceInMiles(waypoints[point].lat,
						  waypoints[point].lon,
						  waypoints[point+1].lat,
						  waypoints[point+1].lon);
			hcPointList.push([waypoints[point+1].lat,
					  waypoints[point+1].lon]);
		    }

		    // Look for any previous polyline at the exact
		    // same location and make it transparent if found.
		    // We only need to find most recently added as its
		    // addition would have taken care of any even
		    // earlier match.  This is done efficiently by
		    // searching only among segments of the same length
		    // which are stored in the values of properties
		    // of the segmentLengths object with the key
		    // as the length of the segment

		    if (segmentLengths.hasOwnProperty(segmentLength)) {
			let sameLengths = segmentLengths[segmentLength];
			for (var sL = sameLengths.length-1; sL >= 0; sL--) {
			    let latLngs = connections[sameLengths[sL]].getLatLngs();
			    // check for match in either direction
			    if ((waypoints[i].lat == latLngs[0].lat &&
				 waypoints[i].lon == latLngs[0].lng &&
				 waypoints[i+1].lat == latLngs[1].lat &&
				 waypoints[i+1].lon == latLngs[1].lng)
				||
				(waypoints[i+1].lat == latLngs[0].lat &&
				 waypoints[i+1].lon == latLngs[0].lng &&
				 waypoints[i].lat == latLngs[1].lat &&
				 waypoints[i].lon == latLngs[1].lng)) {
				connections[sameLengths[sL]].setStyle({opacity: 0});
				// find the route at sameLengths[sL] and add it
				// to the routesHere (concurrencies)
				for (let rNum = 1; rNum < routeInfo.length -1 ; rNum++) {
				    if (routeInfo[rNum].firstConnection > sameLengths[sL]) {
					routesHere.push(rNum-1);
					break;
				    }
				}
				// used to have break; here, but now need to
				// final all concurrencies for popups
			    }
			}
			// add this segment to the existing list of segments
			// of this exact length
			sameLengths.push(nextSegment);
		    }
		    else {
			// this is the first time we've seen a segment of
			// this length, so this creates a new property
			// and initializes its value to a one-element
			// array with this segment number
			segmentLengths[segmentLength] = [ nextSegment ];
		    }

		    // now we have everything to add the listener on this
		    // polyline
		    connectionListener({
			connIndex: nextSegment,
			routes: routesHere,
			endpoints: waypoints[segStart].label + " <-> " + waypoints[segEnd].label,
			length: length,
			hcPointList: hcPointList
		    });
                    nextSegment++;
		}
	    }
	    // set up listener for changes to zoom level and adjust
	    // weight in response
	    map.on('zoomend', zoomChange);
	    zoomChange();
	}
	else {
	    // single route, should be the HB
	    for (var i=0; i<segments.length; i++) {
		var edgePoints = new Array(2);
		edgePoints[0] = [waypoints[i].lat, waypoints[i].lon];
		edgePoints[1] = [waypoints[i+1].lat, waypoints[i+1].lon];
		var segmentLength = distanceInMiles(waypoints[i].lat,
						    waypoints[i].lon,
						    waypoints[i+1].lat,
						    waypoints[i+1].lon);
		totalMiles += segmentLength;
		var color = "#cccccc";
		if (segments[i] == clinched[nextClinchedCheck]) {
		    color = "#ff8080";
		    nextClinchedCheck++;
		    clinchedMiles += segmentLength;
		}
                connections[i] = L.polyline(edgePoints, {
                    color: color,
                    weight: polylineWeight,
                    opacity: 0.75
                }).addTo(map);
		connectionListener({connIndex: i});
	    }
	}
        if (document.getElementById('controlboxinfo') != null) {
  	    document.getElementById('controlboxinfo').innerHTML = ""; //clinchedMiles.toFixed(2) + " of " + totalMiles.toFixed(2) + " miles (" + (clinchedMiles/totalMiles*100).toFixed(1) + "%) clinched by " + traveler + ".";
        }
    }
    else if (genEdges) {
	// this case is only WPT files loaded into HDX, which is an
	// unusual case generally better handled by loading the WPT file
	// into the HB (via the DB), so only minimal support is offered,
	// and no connectionListener is applied
        connections[0] = L.polyline(polypoints, {
            color: "#0000FF",
            weight: polylineWeight,
            opacity: 0.75
        }).addTo(map);
    }
    else {
	console.log("updateMap: unexpected case!");
    }
}

// find a color to use to draw an edge in a graph, where colors represent
// the number of concurrent routes on a segment or traveler frequency
function getGraphEdgeColor(edge) {

    let color;
    
    if (haveTravelers) {
	if (edge.travelerList.length == 0) {
	    // gray for untraveled segments
	    color = "#808080";
	}
	else if (edge.travelerList.length == 1) {
	    // single-traveler routes get special treatment in yellow
	    color = "#FFFF00";
	}
	else {
	    // blue-purple-red scale for others
	    //let rank = 250 * edge.travelerList.length/maxEdgeTravelers;
	    //let r = 5 + rank;
	    //let b = 255 - rank;
	    //
	    // instead:
	    // map 2 to green, through the blues, to red at maxEdgeTravelers
	    //let range = maxEdgeTravelers - 2;
	    //let pos = edge.travelerList.length - 2;
	    let range = Math.log10(maxEdgeTravelers);
	    let pos = Math.log10(edge.travelerList.length);
	    // first half between green and blue, second between blue and red
	    if (pos < range/4) {
		// 120-180 hue, red 0, green 255, blue 0 at 120 to 255 at 180
		color = "rgb(0,255," + (255*(pos/(range/4))) + ")";
	    }
	    else if (pos < range/2) {
		// 180-240 hue, red 0, green 255 at 180 to 0 at 240, blue 255
		color = "rgb(0," + (255-(255*(pos-range/4)/(range/4))) +
		    ",255)";
	    }
	    else if (pos < 3*range/4) {
		// 240-300, red 0 at 240 to 255 at 300, green 0, blue 255
		color = "rgb(" + 255*((pos-range/2)/(range/4)) + ",0,255)";
	    }
	    else {
		// 300-360, red 255, green 0, blue 255 at 300 to 0 at 360
		color = "rgb(255,0," +
		    (255-(255*(pos-3*range/4)/(range/4))) + ")";
	    }
	}
	//console.log("edge has " + edge.travelerList.length + " travelers out of " + maxEdgeTravelers + ", color is " + color);
    }
    else {
	// count the commas, which tell us how many concurrent routes are
	// represented, as they will be comma-separated, then use that to
	// choose a color to indicate the number of routes following the
	// edge
	let concurrent = edge.label.split(",").length;
	color = "";
	switch (concurrent) {
	case 1:
	    color = "#0000FF";
	    break;
	case 2:
	    color = "#00FF00";
	    break;
	case 3:
	    color = "#FF00FF";
	    break;
	case 4:
	    color = "#FFFF00";
	    break;
	default:
	    color = "#FF0000";
	    break;
	}
    }
    return color;
}

// when the map is zoomed, we change the weight of polylines, setting
// the global variable polylineWeight
function zoomChange() {

    let level = map.getZoom();
    if (level < 9) polylineWeight = 2;
    else if (level < 12) polylineWeight = 6;
    else if (level < 15) polylineWeight = 10;
    else polylineWeight = 16;
    for (var i=0; i<connections.length; i++) {
	connections[i].setStyle({weight: polylineWeight});
    }
    if (highlightConnection != null) {
	highlightConnection.setStyle({weight: polylineWeight*2});
    }
}

// variable that would be set by any code that wishes to register
// an additional function to be called on a marker click
var labelClickCallback = null;

// set that variable
function registerMarkerClickListener(func) {

    labelClickCallback = func;
}

function addMarker(marker, markerinfo, i) {

    marker.addTo(map);
    marker.bindPopup(markerinfo);
    marker.on('click', function() {
	if (labelClickCallback != null) {
	    labelClickCallback(i);
	}
    });
}

// note: there is also a labelClickHDX used when selecting start and
// end vertices for HDX algorithm visualizations
// this one is only called by the HB when someone clicks on
// a waypoint in the table (not on the map)
function labelClick(i, label, lat, lon, errors) {

    map.panTo([lat, lon]);
    markers[i].openPopup();
}

// handle clicks on connections (Leaflet Polylines)
function connectionClick(arg){

    let v1;
    let v2;
    let i = arg.connIndex;
    let gotPos = false;
    if (mapStatus == mapStates.HDX) {
	// TMG, GRA, NMP
	if (graphEdges.length > 0) {
	    v1 = waypoints[graphEdges[i].v1];
	    v2 = waypoints[graphEdges[i].v2];
	    gotPos = true;
	}
    }
    else if (mapStatus == mapStates.HB_ROUTE) {
	v1 = waypoints[i];
	v2 = waypoints[i+1];
	gotPos = true;
    }
    else if (mapStatus == mapStates.MAPVIEW) {
	// TBD if anything
    }
    if (gotPos) {
	let midlat = (parseFloat(v1.lat) + parseFloat(v2.lat))/2.0;
	let midlon = (parseFloat(v1.lon) + parseFloat(v2.lon))/2.0;
	map.panTo([midlat, midlon]);
    }
    
    connections[i].bindPopup(connectionInfo(arg));
    connections[i].openPopup();

    // overlay highlight for the clicked segment
    // use the connection's points
    let pointList = connections[i].getLatLngs();
    // but override if a larger list has been built and
    // stored to indicate adjacent segments are part
    if (arg.hasOwnProperty('hcPointList')) {
	pointList = arg.hcPointList;
    }
    highlightConnection = L.polyline(pointList, {
	color: "black",
	weight: polylineWeight*2,
	opacity: 0.4
    }).addTo(map);
}

// called when any connection popup is closed, so we undo any connection
// highlighting
function connectionPopupClose() {

    highlightConnection.remove();
    highlightConnection = null;
}

function markerInfo(i, wpt) {

    var intersections = "";
    if (wpt.hasOwnProperty('intersecting')) {
	intersections = "<p>Intersecting/Concurrent Routes:<br />";
	for (var j = 0; j < wpt.intersecting.length; j++) {
	    r = wpt.intersecting[j];
	    intersections+="<a href=\"/hb/?r=" + r.root + "\">" + r.region + " " + r.route;
	    if (r.banner != "") {
		intersections+=" " + r.banner;
	    }
	    if (r.city != "") {
		intersections+=" (" + r.city + ")";
	    }
	    intersections += "</a><br />";
	}
	intersections += "</p>";
    }
    return '<p style="line-height:160%;"><span style="font-size:24pt;color:black;">' + wpt.label + '</span><br><b>Waypoint ' + i + '<\/b><br><b><a target="_blank" href="http://www.openstreetmap.org/?lat='+wpt.lat+'&lon='+wpt.lon+'">Coords.:<\a><\/b> ' + wpt.lat + '&deg;, ' + wpt.lon + '&deg;<\/p>' + intersections;

}

// generate the popup text when connections[arg.connIndex]'s
// Polyline is clicked
function connectionInfo(arg){

    let i = arg.connIndex;
    let info = '<p style="line-height:160%;">';
    // if a graph edge, get graph info
    if (graphEdges.length > 0) {
	info += '<span style="font-size:24pt; color:black">' +
	    graphEdges[i].label + '</span><br /><b>Edge Number: '
	    + (i) + '<\/b><br><b>Endpoints:<\/b> ' +
	    waypoints[graphEdges[i].v1].label + ' <-> ' +
	    waypoints[graphEdges[i].v2].label +
	    '<br /><b>Distance: </b>' +
	    length_in_current_units(edgeLengthInMiles(graphEdges[i]));
    }
    // maybe we're in a multi-route view, like mapview
    // and info is provided in the parameter
    else if (mapStatus == mapStates.MAPVIEW) {
	let r = arg.routes[0];
	info += '<span style="font-size:18pt; color:black">' +
	    '<a target="_blank" href="/hb?r=' + routeInfo[r].root + '">' +
	    routeInfo[r].label + '</a></span><br />' +
	    arg.endpoints + "<br /><b>Length: </b>" +
	    length_in_current_units(arg.length);
	if (arg.routes.length > 1) {
	    info += "<br /><b>Concurrent with:</b> ";
	}
	for (let j = 1; j < arg.routes.length; j++) {
	    info += '<a target="_blank" href="/hb?r=' +
		routeInfo[arg.routes[j]].root + '">' +
		routeInfo[arg.routes[j]].label + "</a> ";
	}
	info += "<br />";
    }
    // else it is just a route, like in HB, get info from endpoint waypoints
    // but try to avoid hidden waypoints as they're uninteresting to users
    else {
	// build list of waypoint coords for highlightConnection
	arg.hcPointList = new Array();
	let start = i;
	while (start > 0 && !waypoints[start].visible) {
	    start--;
	}
	let end = i+1;
	while (end < waypoints.length -1 && !waypoints[end].visible) {
	    end++;
	}
	info += waypoints[start].label + ' <-> ' +
	    waypoints[end].label + '</br><b>Length: </b> ';
	let length = distanceInMiles(waypoints[start].lat,
				     waypoints[start].lon,
				     waypoints[start+1].lat,
				     waypoints[start+1].lon);
	arg.hcPointList.push([waypoints[start].lat,
			      waypoints[start].lon]);
	arg.hcPointList.push([waypoints[start+1].lat,
			      waypoints[start+1].lon]);
	for (let point = start + 1; point < end; point++) {
	    length += distanceInMiles(waypoints[point].lat,
				      waypoints[point].lon,
				      waypoints[point+1].lat,
				      waypoints[point+1].lon);
	    arg.hcPointList.push([waypoints[point+1].lat,
				  waypoints[point+1].lon]);

	}

	info += length_in_current_units(length);
    }
    
    if (haveTravelers) {
	let travelers = '';
	for (let j = 0; j < graphEdges[i].travelerList.length; j++) {
	    travelers += travelerNames[graphEdges[i].travelerList[j]] + ' ';
	}
	
	info += '<br /><span title="' + travelers + '"><b>' + graphEdges[i].travelerList.length + ' Traveler';
	if (graphEdges[i].travelerList.length != 1) {
	    info += 's';
	}
	info += '</b>';
	if (graphEdges[i].travelerList.length > 0) {
	    if (graphEdges[i].travelerList.length <= 5) {
		info += ': ' + travelers;
	    }
	    else {
		info += ' (mouse over for list)';
	    }
	}
	info += '</span>';
    }
    info += '</p>';
    return info;
}


// compute the length of an edge in miles
function edgeLengthInMiles(e) {

    if (!e.hasOwnProperty("length")) {
	let len = 0.0;
	if (e.via == null) {
	    // no intermediate points: easy case
	    len = distanceInMiles(waypoints[e.v1].lat, waypoints[e.v1].lon,
				  waypoints[e.v2].lat, waypoints[e.v2].lon);
	}
	else {
	    // account for intermediate points in "via" array
	    len = distanceInMiles(waypoints[e.v1].lat, waypoints[e.v1].lon,
				  parseFloat(e.via[0]), parseFloat(e.via[1]));
	    for (var pos = 0; pos < e.via.length - 2; pos += 2) {
		len += distanceInMiles(parseFloat(e.via[pos]),
				       parseFloat(e.via[pos+1]),
				       parseFloat(e.via[pos+2]),
				       parseFloat(e.via[pos+3]));
	    }
	    len += distanceInMiles(parseFloat(e.via[e.via.length-2]),
				   parseFloat(e.via[e.via.length-1]),
				   waypoints[e.v2].lat, waypoints[e.v2].lon);
	}
	e.length = len;
    }
    return e.length;
}

// compute distance in miles between two lat/lon points
function distanceInMiles(lat1, lon1, lat2, lon2) {
    if(lat1 == lat2 && lon1 == lon2)
	return 0.;
    
    var rad = 3963.;
    var deg2rad = Math.PI/180.;
    var ang = Math.cos(lat1 * deg2rad) * Math.cos(lat2 * deg2rad) * Math.cos((lon1 - lon2)*deg2rad) + Math.sin(lat1 * deg2rad) * Math.sin(lat2 * deg2rad);
    return Math.acos(ang) * 1.02112 * rad;
}

// compute distance in feet between two lat/lon points
function distanceInFeet(lat1, lon1, lat2, lon2) {
    if(lat1 == lat2 && lon1 == lon2)
	return 0.;
    
    var rad = 3963.;
    var deg2rad = Math.PI/180.;
    var ang = Math.cos(lat1 * deg2rad) * Math.cos(lat2 * deg2rad) * Math.cos((lon1 - lon2)*deg2rad) + Math.sin(lat1 * deg2rad) * Math.sin(lat2 * deg2rad);
    return Math.acos(ang) * 1.02112 * rad * 5280;
}

// GraphEdge constructor, vertex numbers can come in as strings or
// numbers, will store as numbers
function GraphEdge(v1, v2, label, trav, via) {

    // v1 and v2 are the indices into the vertices array of
    // the edge's endpoints
    if (typeof v1 === 'string') {
	this.v1 = parseInt(v1);
	this.v2 = parseInt(v2);
    }
    else {
	this.v1 = v1;
	this.v2 = v2;
    }
    // edge label
    this.label = label;

    // traveler hex string
    this.travelerList = null;
    if (trav != null) {
	// parse the hex code into a list of travelers of this segment
	this.travelerList = new Array();
	// the bits of the first hex character represent the travels
	// of the first 4 travelers (0-3), the next character represents
	// the travels of the next 4 travelers (4-7), etc.
	let nextTrav = 0;
	for (let pos = 0; pos < trav.length; pos++) {
	    switch (trav[pos]) {
	    case '1':
		this.travelerList.push(nextTrav);
		break;
	    case '2':
		this.travelerList.push(nextTrav+1);
		break;
	    case '3':
		this.travelerList.push(nextTrav);
		this.travelerList.push(nextTrav+1);
		break;
	    case '4':
		this.travelerList.push(nextTrav+2);
		break;
	    case '5':
		this.travelerList.push(nextTrav);
		this.travelerList.push(nextTrav+2);
		break;
	    case '6':
		this.travelerList.push(nextTrav+1);
		this.travelerList.push(nextTrav+2);
		break;
	    case '7':
		this.travelerList.push(nextTrav);
		this.travelerList.push(nextTrav+1);
		this.travelerList.push(nextTrav+2);
		break;
	    case '8':
		this.travelerList.push(nextTrav+3);
		break;
	    case '9':
		this.travelerList.push(nextTrav);
		this.travelerList.push(nextTrav+3);
		break;
	    case 'A':
		this.travelerList.push(nextTrav+1);
		this.travelerList.push(nextTrav+3);
		break;
	    case 'B':
		this.travelerList.push(nextTrav);
		this.travelerList.push(nextTrav+1);
		this.travelerList.push(nextTrav+3);
		break;
	    case 'C':
		this.travelerList.push(nextTrav+2);
		this.travelerList.push(nextTrav+3);
		break;
	    case 'D':
		this.travelerList.push(nextTrav);
		this.travelerList.push(nextTrav+2);
		this.travelerList.push(nextTrav+3);
		break;
	    case 'E':
		this.travelerList.push(nextTrav+1);
		this.travelerList.push(nextTrav+2);
		this.travelerList.push(nextTrav+3);
		break;
	    case 'F':
		this.travelerList.push(nextTrav);
		this.travelerList.push(nextTrav+1);
		this.travelerList.push(nextTrav+2);
		this.travelerList.push(nextTrav+3);
		break;
	    }
	    nextTrav += 4;
	}
    }

    // array of shaping points (or null)
    this.via = via;

    return this;
}

// callback for when the hideMarkers checkbox is clicked
function showMarkersClicked() {

    var showThem = document.getElementById('showMarkers').checked;
    if (showThem) {
	for (var i = 0; i < waypoints.length; i++) {
	    if (waypoints[i].visible) {
		addMarker(markers[i], markerinfo[i], i);
	    }
	}
    }
    else {
	for (var i = 0; i < waypoints.length; i++) {
	    markers[i].remove();
	}
    }
}

// listen for clicks on connections/Polylines
function connectionListener(arg){
    connections[arg.connIndex].on('click',
		      function(e){
			  connectionClick(arg);
		      });
    connections[arg.connIndex].on('popupclose',
		      function(e){
			  connectionPopupClose();
		      });
}

// for mapview, highlighting route segments when route is hovered over
// in the table of routes
function mapviewRouteHover(root) {

    // find the route in the routeInfo array
    let firstWaypoint = 0;
    let lastWaypoint = waypoints.length-1;
    for (let routeIndex = 0; routeIndex < routeInfo.length; routeIndex++) {
	if (routeInfo[routeIndex].root == root) {
	    firstWaypoint = routeInfo[routeIndex].firstWaypoint;
	    if (routeIndex != routeInfo.length - 1) {
		lastWaypoint = routeInfo[routeIndex+1].firstWaypoint - 1;
	    }
	    break;
	}
    }
    let pointList = new Array();
    for (let i = firstWaypoint; i <= lastWaypoint; i++) {
	pointList.push([waypoints[i].lat, waypoints[i].lon]);
    }
    mapviewHoverRoute = L.polyline(pointList, {
	color: "black",
	weight: polylineWeight*2,
	opacity: 0.4
    }).addTo(map);
}

function mapviewRouteEndHover() {

    mapviewHoverRoute.remove();
    mapviewHoverRoute = null;
}

function redirect(url) {
    var win = window.open(url);
    win.focus();
}

// JS debug window by Mike Maddox from
// http://javascript-today.blogspot.com/2008/07/how-about-quick-debug-output-window.html
var DBG = {
    write : function(txt){
	if (!window.dbgwnd){
	    window.dbgwnd = window.open("","debug","status=0,toolbar=0,location=0,menubar=0,directories=0,resizable=0,scrollbars=1,width=600,height=250");
	    window.dbgwnd.document.write('<html><head></head><body style="background-color:black"><div id="main" style="color:green;font-size:12px;font-family:Courier New;"></div></body></html>');
	}
	var x = window.dbgwnd.document.getElementById("main");
	this.line=(this.line==null)?1:this.line+=1;
	txt=this.line+': '+txt;
	if (x.innerHTML == ""){
	    x.innerHTML = txt;
	}
	else {
	    x.innerHTML = txt + "<br/>" + x.innerHTML;
	}
    }
}
